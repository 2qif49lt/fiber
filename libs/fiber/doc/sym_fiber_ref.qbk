[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:sym_fiber_management Symmetric Fiber]

[heading Synopsis]

Each __sym_fiber__ class represents a user-space context of execution. Objects of
type __sym_fiber__ are characterized by providing two basic operations: __create__
(constructor) and __suspend__ (__fiber_switch_to__).
   
The constructor of __sym_fiber__ accepts a function which acts as the main body
of the fiber. Creating a fiber doesn't start its execution. The fiber begins
in suspended state with its __continuation_point__ set to the first instruction in
its main body.
It is characeristic for symmetric fibers to provide a single control-transfer operation
(__fiber_switch_to__) allowing to pass the control explicitly among themself.
The __continuation_point__ of the fiber which initiates the control transfer will be
saved so that the next time the cotnrol is transfered back its execution will continue
at the exact point where it was suspended.
When a fiber returns from its main function the fiber is said to be finished and can
not be futher resumed. If a fibers main function returns and the fiber was not linked
against another one, the application terminates.

__sym_fiber__ supports copy- and move-semantics.

    boost::sym_fiber f1; // not-a-fiber

    void fn()
    {
        boost::sym_fiber f2( some_fn, boost::sym_fiber::default_stacksize);
        std::cout << f2.get_id() << std::endl;
        f2.run();
    }


[note If fibers are migrated between threads the code called by a fiber must not
use thread-local-storage.]


[heading Creating]

A new fiber is created by passing an object of a callable type that can be
invoked with no parameters to the constructor. The object is then copied into
internal storage, and invoked on the newly-created fiber. If the object must not
(or cannot) be copied, then `boost::ref` can be used to pass in a reference to
the function object. In this case, the user of __boost_fiber__ must ensure that
the referred-to object outlives the newly-created fiber.

    struct callable
    { void operator()(); };

    boost::sym_fiber copies_are_safe()
    {
        callable x;
        return boost::sym_fiber( x);
    } // x is destroyed, but the newly-created fiber has a copy, so this is OK

    boost::sym_fiber oops()
    {
        callable x;
        return boost::sym_fiber( boost::ref( x), boost::sym_fiber::default_stacksize);
    } // x is destroyed, but the newly-created fiber still has a reference
      // this leads to undefined behaviour

If you wish to construct an instance of __sym_fiber__ with a function or callable
object that requires arguments to be supplied, this can be done by passing
additional arguments to the __sym_fiber__ constructor:

    void find_the_question( int the_answer);

    boost::sym_fiber deep_thought_2(
        find_the_question, 42, boost::sym_fiber::default_stacksize);

The arguments are ['copied] into the internal fiber structure: if a reference
is required, use `boost::ref`, just as for references to callable functions.

[caution Functions passed to the __sym_fiber__ must not throw exceptions.]


[heading Control Transfer]

__sym_fiber__ provides only one operation to transfer the execution control
between different fibers. This allows the symmetric fibers to transfer the
execution control among themselfs (chain of fiber invocations). The
__continuation_point__ of the `other` fiber is started/resumed if
__fiber_switch_to__ is called with `other` as its argument.

    // create `current_fiber` which represent the current execution context
    boost::sym_fiber current_fiber( boost::sym_fiber::from_current-context() );

    // create `my_fiber` which will execute `my_function()`
    boost::sym_fiber my_fiber( my_function, boost::sym_fiber:default_stacksize);

    // jump to execution context of `my_fiber`
    // run `my_function`
    current_fiber.switch_to( my_fiber);

    // this section will be entered if `my_function()` calls
    // `my_fiber.switch_to( current_fiber)`


[heading Linking against other Fiber]

If the main function of a symmetric fiber returns the application terminates.
If desired it is possible to link to another fiber which will be executed after
a fiber is finished. For this purpose the constructor takes a __sym_fiber__ as
last argument.

    // create `current_fiber` which represent the current execution context
    boost::sym_fiber current_fiber( boost::sym_fiber::from_current-context() );

    // create `my_fiber` which will execute `my_function()` and link
    // against `current_fiber` which will be resumed after `my_function()` returns
    boost::sym_fiber my_fiber( my_function, boost::sym_fiber:default_stacksize, current_fiber);

    // jump to execution context of `my_fiber`
    // run `my_function`
    current_fiber.switch_to( my_fiber);

    // this section will be entered if `my_function()` returns
    ...

[heading Fiber IDs]

Objects of class __sym_fiber_id__ can be used to identify fibers. Each running fiber
has a unique ID obtainable from the corresponding __sym_fiber__ by calling 
__sym_get_id__ member function. Objects of class __sym_fiber_id__ can be copied, and
used as keys in associative containers: the full range of comparison operators
is provided. Fiber IDs can also be written to an output stream using the stream
insertion operator, though the output format is unspecified.

Each instance of __sym_fiber_id__ either refers to some fiber, or __not_a_fiber__.
Instances that refer to __not_a_fiber__ compare equal to each other, but not
equal to any instances that refer to an actual fiber.
The comparison operators on __sym_fiber_id__ yield a total order for every non-equal
fiber ID.


[heading Example]

The example below demonstrates that the function `fn` is executed in the context
of the fiber `f` and the local state of `fn` is preserved (value of `i` in the
for loop).

    boost::sym_fiber f, current;

    void fn( int n)
    {
        for ( int i = 0; i < n; ++i)
        {
            std::cout << i << " iteration" << std::endl;
            // jump back to main
            // value of i will be preserved
            f.switch_to( current);
            // if we return from f.switch_to( current)
            // current.switch_to( f) was called again
        }
    }

    int main()
    {
        current = boost::sym_fiber::from_current_context();
        f = boost::sym_fiber( fn, 5, current);

        std::cout << "start" << std::endl;
        while ( ! f.finished() )
            current.switch_to( f); // jump to context of fn()
        std::cout << "finish" << std::endl;

        return EXIT_SUCCESS;
    }


[section:sym_fiber Class `sym_fiber`]

    #include <boost/fiber/sym_fiber.hpp>

    class sym_fiber
    {
    public:
        static std::size_t max_stacksize;
        static std::size_t min_stacksize;
        static std::size_t default_stacksize; // 256 kB

        static sym_fiber from_current_cotnext();

        sym_fiber();

        template< typename Fn >
        explicit sym_fiber( Fn fn, std::size_t stacksize);

        template< typename Fn >
        explicit sym_fiber( Fn fn, std::size_t stacksize, sym_fiber & nxt);

        template< typename Fn, typename A1, typename A2,... >
        sym_fiber( Fn fn, A1 a1, A2 a2,..., std::size_t stacksize);

        template< typename Fn, typename A1, typename A2,... >
        sym_fiber( Fn fn, A1 a1, A2 a2,..., std::size_t stacksize, sym_fiber & nxt);

        sym_fiber( sym_fiber const& other);
        sym_fiber & operator=( sym_fiber const& other);

        // move support
        template< typename Fn >
        explicit sym_fiber( Fn && fn, std::size_t stacksize);

        template< typename Fn >
        explicit sym_fiber( Fn && fn, std::size_t stacksize, sym_fiber & nxt);

        sym_fiber( sym_fiber && other);

        sym_fiber & operator=( sym_fiber && other);

        operator unspecified-bool-type() const;
        
        bool operator!() const;
        
        void swap( sym_fiber & other);
        
        id get_id() const;
        
        bool operator==( sym_fiber const&) const;
        bool operator!=( sym_fiber const&) const;
        
        void switch_to( sym_fiber & other);

        bool finished() const;
    };

    void swap( sym_fiber & lhs, sym_fiber & rhs);


[section:create `static sym_fiber from_current_context()`]
[variablelist
[[Effects:] [Creates a fiber attached to current execution context.
The fiber doesn't manage the stack.]]
[[Postconditions:] [`*this` refers to the newly created fiber.]]
[[Throws:] [__bad_alloc__.]]
]
[endsect]

[section:default_constructor `sym_fiber()`]
[variablelist
[[Effects:] [Constructs a __sym_fiber__ instance that refers to __not_a_fiber__.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:callable_constructor_stack1 `template< typename Fn > sym_fiber( Fn fn, std::size_t stacksize)`]
[variablelist
[[Effects:] [`fn` is copied into storage managed internally by the fiber, that
copy is invoked on a newly-created fiber.]]
[[Postconditions:] [`*this` refers to the newly created fiber.]]
[[Throws:] [__bad_alloc__.]]
]
[endsect]

[section:callable_constructor_stack2 `template< typename Fn > sym_fiber( Fn fn, std::size_t stacksize, sym_fiber & other)`]
[variablelist
[[Effects:] [`fn` is copied into storage managed internally by the fiber, that
copy is invoked on a newly-created fiber. If `fn` returns `nxt` will be invoked.]]
[[Postconditions:] [`*this` refers to the newly created fiber.]]
[[Throws:] [__bad_alloc__.]]
]
[endsect]

[section:multiple_argument_constructor1 `template< typename Fn, typename A1, typename A2,... > fiber( Fn fn, A1 a1, A2 a2,..., std::size_t stacksize)`]
[variablelist
[[Preconditions:] [`Fn` and each `A`n must by copyable or movable.]]
[[Effects:] [As if `sym_fiber( boost::bind( fn, a1, a2,...) )`. Consequently,
`fn` and each `a`n are copied into internal storage for access by the new fiber.]]
[[Postconditions:] [`*this` refers to the newly created fiber.]]
[[Throws:] [__bad_alloc__]]
[[Note:] [Currently up to nine additional arguments `a1` to `a9` can be
specified in addition to the function `fn`.]]
]
[endsect]

[section:multiple_argument_constructor2 `template< typename Fn, typename A1, typename A2,... > fiber( Fn fn, A1 a1, A2 a2,..., std::size_t stacksize, sym_fiber & nxt)`]
[variablelist
[[Preconditions:] [`Fn` and each `A`n must by copyable or movable.]]
[[Effects:] [As if `sym_fiber( boost::bind( fn, a1, a2,...) )`. Consequently,
`fn` and each `a`n are copied into internal storage for access by the new fiber.
If `fn` returns `nxt` will be invoked automatically.]]
[[Postconditions:] [`*this` refers to the newly created fiber.]]
[[Throws:] [__bad_alloc__]]
[[Note:] [Currently up to nine additional arguments `a1` to `a9` can be
specified in addition to the function `fn`.]]
]
[endsect]

[section:get_id `sym_fiber::id get_id() const`]
[variablelist
[[Returns:] [If `*this` refers to a fiber, an instance of __sym_fiber_id__ that
represents that fiber. Otherwise returns a default-constructed __sym_fiber_id__.]]
[[Throws:] [Nothing.]]
]

[endsect]

[section:switch_to `void switch_to( sym_fiber& other)`]
[variablelist
[[Preconditions:] [`other` and `*this` are not a __not_a_fiber__.]]
[[Effects:] [Save current execution context and transfer execution control to
`other`.]]
[[Throws:] [__fiber_moved__ if `*this` or `other` are __not_a_fiber__.]]
]
[endsect]

[section:finished `bool finished() const`]
[variablelist
[[Effects:] [Returns `true` if fiber has finished.]]
[[Throws:] [__fiber_moved__ if `*this` is __not_a_fiber__.]]
]
[endsect]

[section:unspec_operator `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to a fiber, the function returns true. Otherwise
false.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:not_operator `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers not to a fiber, the function returns true.
Otherwise false.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:equals `bool operator==( sym_fiber const& other) const`]
[variablelist
[[Returns:] [`get_id()==other.get_id()`]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:not_equals `bool operator!=( sym_fiber const& other) const`]
[variablelist
[[Returns:] [`get_id()!=other.get_id()`]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:swap `void swap( sym_fiber & other)`]
[variablelist
[[Effects:] [Exchanges the fibers associated with `*this` and `other`, so
`*this` is associated with the fiber associated with `other` prior to the call,
and vice-versa.]]
[[Postconditions:] [`this->get_id()` returns the same value as `other.get_id()`
prior to the call. `other.get_id()` returns the same value as `this->get_id()`
prior to the call.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:non_member_swap Non-member function `swap()`]

    #include <boost/fiber/sym_fiber.hpp>

    void swap( sym_fiber & lhs, sym_fiber & rhs);

[variablelist
[[Effects:] [[link fiber.sym_fiber_management.sym_fiber.swap
`lhs.swap( rhs)`].]]
[[Throws:] [Nothing.]]
]
[endsect]


[section:id Class `boost::sym_fiber::id`]

    #include <boost/fiber/fiber.hpp>

    class sym_fiber::id
    {
    public:
        id();

        bool operator==( id const& y) const;
        bool operator!=( id const& y) const;
        bool operator<( id const& y) const;
        bool operator>( id const& y) const;
        bool operator<=( id const& y) const;
        bool operator>=( id const& y) const;

        template< typename charT, typename traitsT >
        friend std::basic_ostream< charT, traitsT > & 
        operator<<( std::basic_ostream<charT, traitsT > & os, id const& x);
    };

[section:constructor `id()`]
[variablelist
[[Effects:] [Constructs a __sym_fiber_id__ instance that represents
__not_a_fiber__.]]
[[Throws:] [Nothing]]
]
[endsect]

[section:is_equal `bool operator==( id const& y) const`]
[variablelist
[[Returns:] [`true` if `*this` and `y` both represent the same fiber of
execution, or both represent __not_a_fiber__, `false` otherwise.]]
[[Throws:] [Nothing]]
]
[endsect]

[section:not_equal `bool operator!=( id const& y) const`]
[variablelist
[[Returns:] [`true` if `*this` and `y` represent different fibers of execution,
or one represents a fiber of execution, and the other represent __not_a_fiber__,
`false` otherwise.]]
[[Throws:] [Nothing]]
]
[endsect]

[section:less_than `bool operator<( id const& y) const`]
[variablelist
[[Returns:] [`true` if `*this!=y` is `true` and the implementation-defined total
order of __sym_fiber_id__ values places `*this` before `y`, `false` otherwise.]]
[[Throws:] [Nothing]]
[[Note:] [A __sym_fiber_id__ instance representing __not_a_fiber__ will alws
compare less than an instance representing a fiber of
execution.]]
]
[endsect]

[section:greater_than `bool operator>( id const& y) const`]
[variablelist
[[Returns:] [`y<*this`]]
[[Throws:] [Nothing]]
]
[endsect]

[section:less_than_or_equal `bool operator<=( id const& y) const`]
[variablelist
[[Returns:] [`!(y<*this)`]]
[[Throws:] [Nothing]]
]
[endsect]

[section:greater_than_or_equal `bool operator>=( id const& y) const`]
[variablelist
[[Returns:] [`!(*this<y)`]]
[[Throws:] [Nothing]]
]
[endsect]

[section:stream_out Non-member template function `operator<<`]

        template< typename charT, typename traitsT >
        friend std::basic_ostream< charT, traitsT > & 
        operator<<( std::basic_ostream<charT, traitsT > & os, id const& x);

[variablelist
[[Effects:] [Writes a representation of the __sym_fiber_id__ instance `x` to
the stream `os`, such that the representation of two instances of
__sym_fiber_id__ `a` and `b` is the same if `a==b`, and different if `a!=b`.]]
[[Returns:] [`os`]]
]
[endsect]

[endsect]

[endsect]

[endsect]
