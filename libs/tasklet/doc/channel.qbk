[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:channels (Un)Bounded channels]

__boost_tasklet__ provides a bounded and a unbounded channel suitable to
synchonize tasklets via message passing.

    typedef boost::tasklets::unbounded_channel< int > channel_t;

    void send( channel_t & channel)
    {
        for ( int i = 0; i < 5; ++i)
            channel.put( i);
        channel.deactivate();
    }

    void recv( channel_t & channel)
    {
        boost::optional< int > value;
        while ( channel.take( value) )
        { std::cout << "received " << * value << std::endl; }
    }

    boost::tasklets::scheduler<> sched;
    channel_t channel;
    sched.make_tasklet( send, ref( channel) );
    sched.make_tasklet( recv, ref( channel) );

    for (;;)
    {
        while ( sched.run() );
        if ( sched.empty() ) break;
    }


[section:unbounded_channel Template `template< typename T > unbounded_channel`]

    #include <boost/tasklet/unbounded_channel.hpp>

    template< typename T >
    class unbounded_channel : private noncopyable
    {
    public:
        void deactivate();

        bool empty();

        void put( T const& t);

        bool take( boost::optional< T > & va);

        bool try_take( boost::optional< T > & va);
    };

[section:deactivate `void deactivate()`]
[variablelist
[[Effects:] [Deactivates the channel. No values can be put after calling
`this->deactivate`. Tasklets blocked in
`this->take()` will be return.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:empty `bool empty()`]
[variablelist
[[Effects:] [Returns `true` if the channel currently contains no data.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:put `void put( T const& t)`]
[variablelist
[[Effects:] [Enqueues the value in the channel and wakes up a tasklet waiting
for new data available from the
channel.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:take `bool take( boost::optional< T > & va)`]
[variablelist
[[Effects:] [Dequeues a value from the channel. If no data is available from the
channel the tasklet gets suspended until new data are enqueued (return value
`true` and va contains dequeued value) or the channel gets deactiveted and the
function returns `false`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:try_take `bool try_take( boost::optional< T > & va)`]
[variablelist
[[Effects:] [Dequeues a value from the channel. If no data is available from the
channel the function returns `false`. Otherwise it returns `true` and `va`
contains the dequed value.]]
[[Throws:] [Nothing.]]
]
[endsect]

[endsect]


[section:bounded_channel Template `template< typename T > bounded_channel`]

    #include <boost/tasklet/bounded_channel.hpp>

    template< typename T >
    class bounded_channel : private noncopyable
    {
    public:
        bounded_channel( std::size_t wm);

        bounded_channel( std::size_t hwm, std::size_t lwm);

        void deactivate();

        bool empty();

        void put( T const& t);

        bool take( boost::optional< T > & va);

        bool try_take( boost::optional< T > & va);
    };

[section:constructor `bounded_channel( std::size_t wm)`]
[variablelist
[[Effects:] [Constructs an object of class `bounded_channel` which will contain
a maximum of `wm` items.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:constructor2 `bounded_channel( std::size_t hwm, std::size_t lwm)`]
[variablelist
[[Effects:] [Constructs an object of class `bounded_channel` which will contain
a high-watermark of `hwm`
and a low-watermark of `lwm` items.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:deactivate `void deactivate()`]
[variablelist
[[Effects:] [Deactivates the channel. No values can be put after calling
`this->deactivate`. Tasklets blocked in `this->take()` will be return.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:empty `bool empty()`]
[variablelist
[[Effects:] [Returns `true` if the channel currently contains no data.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:put `void put( T const& t)`]
[variablelist
[[Effects:] [Enqueues the value in the channel and wakes up a tasklet waiting
for new data available from the channel. If the watermark has reached the
tasklet putting the value will be supended until at least one item was
dequeued.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:take `bool take( boost::optional< T > & va)`]
[variablelist
[[Effects:] [Dequeues a value from the channel. If no data is available from the
channel the tasklet gets suspended until new data are enqueued (return value
`true` and va contains dequeued value) or the channel gets deactiveted and the
function returns `false`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:try_take `bool try_take( boost::optional< T > & va)`]
[variablelist
[[Effects:] [Dequeues a value from the channel. If no data is available from the
channel the function returns `false`. Otherwise it returns `true` and `va`
contains the dequed value.]]
[[Throws:] [Nothing.]]
]
[endsect]

[endsect]

[endsect]
