[/
          Copyright Oliver Kowalke 2013.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:rational Rational]

[heading Distinction between coroutines and fibers]

The fiber library extends the coroutine library by adding a scheduler and
synchronization mechanisms.

    * a coroutine yields

    * a fiber blocks

When a coroutine yields, it passes control directly to its caller (or, in the
case of symmetric coroutines, a designated other coroutine).
When a fiber blocks, it implicitly passes control to the fiber scheduler.
Coroutines have no scheduler because they need no scheduler.
[footnote [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf
'N4024: Distinguishing coroutines and fibers']].


[heading what about transactional memory]

GCC support transactional memory since version 4.7. Unfortunately testes showed
that transactional memory is slower (ca. 4x) than using spinlocks using atomics.
If transactional memory will be improved (supporting hybrid tm), spinlocks will
be replaced by __transaction_atomic{} statements surrounding the critical
sections. 


[heading synchronization between fibers running in different threads]

Synchronization classes from __boost_thread__ do block the entire thread. In
contrast to this the synchronization clases from __boost_fiber__ do block only
the fiber, so that the thread is able to schedule and run other fibers in the
meantime.
The synchronization classes from __boost_fiber__ are designed to be thread-safe,
e.g. it is possible to synchronize fibers running in different schedulers
(different threads) or running int the same scheduler (same thread).


[endsect]
