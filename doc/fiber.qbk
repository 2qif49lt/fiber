[/
  (C) Copyright 2013 Oliver Kowalke.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section Class fiber]

[heading Synopsis]

Each __fiber__ represents a micro-thread which will be launched and
managed cooperativly by a scheduler. Objects of type __fiber__ are only
moveable.

    boost::fibers::fiber f1; // not-a-fiber

    void f()
    {
        boost::fibers::fiber f2( some_fn);

        f1 = boost::move( f2); // f2 moved to f1
    }


[heading Launching]

A new fiber is launched by passing an object of a callable type that can be
invoked with no parameters.
If the object must not (or cannot) be copied, then ['boost::ref] can be used to
pass in a reference to the function object. In this case, the user must ensure
that the referred-to object outlives the newly-created fiber.

    struct callable
    { void operator()(); };

    boost::fibers::fiber copies_are_safe()
    {
        callable x;
        return boost::fibers::fiber( x);
    } // x is destroyed, but the newly-created fiber has a copy, so this is OK

    boost::fibers::fiber oops()
    {
        callable x;
        return boost::fibers::fiber( boost::ref( x) );
    } // x is destroyed, but the newly-created fiber still has a reference
      // this leads to undefined behaviour

The execution control is immediately transfered to the spawned __fiber__ at
construction. If the constructor returns the __fiber__ might be complete or the
fiber is waiting/sleeping.


[heading Exceptions]

Exceptions thrown by the function or callable object passed to the __fiber__
constructor are consumed by the framework (if it required to know which
exceptions was thrown use __future__ and __packaged_task__).


[heading Joining]

In order to wait for a fiber to finish, the __join__ member functions of the
__fiber__ object can be used. __join__ will block until the __fiber__ object
has completed.
If the __fiber__ has already completed, or the __fiber__ object represents
__not_a_fiber__, then __join__ returns immediately.

    void some_fn()
    { ... }

    boost::fibers::fiber f( some_fn);
    f.join();


[heading Fiber IDs]

Objects of class __id__ can be used to identify fibers. Each running
__fiber__ has a unique __id__ obtainable from the corresponding __fiber__
by calling the __get_id__ member function.
Objects of class __id__ can be copied, and used as keys in associative
containers: the full range of comparison operators is provided.
They can also be written to an output stream using the stream insertion
operator, though the output format is unspecified.

Each instance of __id__ either refers to some fiber, or __not_a_fiber__.
Instances that refer to __not_a_fiber__ compare equal to each other, but
not equal to any instances that refer to an actual fiber. The comparison
operators on __id__ yield a total order for every non-equal __id__.


        class fiber
        {
        public:
            typedef uspecified-class        id;

            fiber() noexcept;

            template< typename Fn >
            explicit fiber( Fn && fn, attributes const& attr = attributes(),
                            stack_allocator const& stack_alloc = stack_allocator(),
                            std::allocator< fiber > const& alloc =
                                 std::allocator< fiber >() );

            template< typename Fn, typename StackAllocator >
            explicit fiber( Fn && fn, attributes const& attr,
                            StackAllocator const& stack_alloc,
                            std::allocator< fiber > const& alloc =
                                 std::allocator< fiber >() );

            template< typename Fn, typename StackAllocator, typename Allocator >
            explicit fiber( Fn && fn, attributes const& attr,
                            StackAllocator const& stack_alloc,
                            Allocator const& alloc);

            ~fiber();

            fiber( BOOST_RV_REF( fiber) other) noexcept;

            fiber & operator=( BOOST_RV_REF( fiber) other) noexcept;

            operator safe_bool() const noexcept;

            bool operator!() const noexcept;

            void swap( fiber & other) noexcept;

            bool joinable() const noexcept;

            id get_id() const noexcept;

            int priority() const noexcept;

            void priority( int) noexcept;

            void detach() noexcept;

            void join();

            void interrupt() noexcept;
        };

        bool operator<( fiber const& l, fiber const& r);

        void swap( fiber & l, fiber & r);


[endsect]
