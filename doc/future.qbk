[/
          Copyright Oliver Kowalke 2013.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:future Future]

A future provides a mechanism to access the result of an asynchronous operation.

[heading Template `future<>`]

        template< typename R >
        class future
        {
        public:
            future() noexcept;

            future( future && other) noexcept;

            future( future const& other) = delete;

            ~future();

            future & operator=( future && other) noexcept;

            future & operator=( future const& other) = delete;

            void swap( future & other) noexcept;

            operator safe_bool() const noexcept;

            bool operator!() const noexcept;

            bool valid() const noexcept;

            shared_future< R > share();

            R get();

            void wait() const;

            template< class Rep, class Period >
            future_status wait_for( chrono::duration< Rep, Period > const& timeout_duration) const;

            future_status wait_until( clock_type::time_point const& timeout_time) const;
        };

[heading Default constructor]

        future();

[variablelist
[[Effects:] [Creates a future with no shared state.
After construction is `false == vaild()`.]]
[[Throws:] [Nothing.]]
]

[heading Move constructor]

        future( future && other) noexcept;

[variablelist
[[Effects:] [Constructs a future with the shared state of other.
After construction is `false == other.valid()`]]
[[Throws:] [Nothing.]]
]

[heading Destructor]

        ~future();

[variablelist
[[Effects:] [Destructs the future; ownership is abandoned.]]
[[Throws:] [Nothing.]]
]


[heading Template `shared_future<>`]

        template< typename R >
        class shared_future
        {
        public:
            shared_future() noexcept;

            ~shared_future();

            shared_future( shared_future const& other);

            shared_future( future< R > && other) noexcept;

            shared_future( shared_future && other) noexcept;

            shared_future & operator=( shared_future && other) noexcept;

            shared_future & operator=( shared_future const& other) noexcept;

            void swap( shared_future & other) noexcept;

            operator safe_bool() const noexcept;

            bool operator!() const noexcept;

            bool valid() const noexcept;

            R get();

            void wait() const;

            template< class Rep, class Period >
            future_status wait_for( chrono::duration< Rep, Period > const& timeout_duration) const;

            future_status wait_until( clock_type::time_point const& timeout_time) const;
        };

[endsect]
